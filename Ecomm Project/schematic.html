<!doctype html>
<html lang="en">
  <head>
    <link rel="stylesheet" href="style.css">
    <meta charset="utf-8" />
    <title>Schematic – Appliance Parts</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="styles.css" />
  </head>
  <body>
    <!-- Header (shared) -->
    <header>
      <a href="index.html" aria-label="Home">Appliance Parts</a>
      <form id="header-search" role="search" aria-label="Search">
        <input
          id="header-search-input"
          type="search"
          placeholder="Enter Model or Part Number"
          autocomplete="off"
          required
        />
        <button type="submit">Search</button>
      </form>
      <nav>
        <a id="cart-link" href="cart.html" aria-label="Cart">
          Cart (<span id="cart-count">0</span>)
        </a>
      </nav>
    </header>

    <main>
      <h1 id="page-title">Schematic</h1>

      <!-- Image left, table right (styles.css positions/sticks image) -->
      <section id="schematic" class="schematic-block" hidden>
        <h2 id="schem-name" class="schem-title"></h2>

        <!-- Left: schematic image -->
        <img id="schem-img" alt="Schematic" />

        <!-- Right: parts table (independent scroll) -->
        <div class="table-wrap">
          <table id="parts-table">
            <thead>
              <tr>
                <th>Diagram Number</th>
                <th>Part Number</th>
                <th>Name</th>
                <th>Status</th>
                <th>Inventory</th>
                <th>Price</th>
              </tr>
            </thead>
            <tbody id="parts-body"></tbody>
          </table>
        </div>
      </section>

      <div id="loading" class="panel">Loading…</div>
      <div id="error" class="panel" hidden></div>
    </main>

    <!-- CSV-backed data + router -->
    <script src="search.js"></script>
    <script>
      /* ---------- Header wiring ---------- */
      (function initHeader(){
        try {
          const count = Number(localStorage.getItem("cartCount") || "0");
          document.getElementById("cart-count").textContent = String(count);
        } catch (e) {}
        document.getElementById("header-search").addEventListener("submit", function(e){
          e.preventDefault();
          const q = (document.getElementById("header-search-input").value || "").trim();
          if (q) runSearch(q);
        });
      })();

      /* ---------- Small utils ---------- */
      const qp = (k) => new URLSearchParams(location.search).get(k) || "";
      const setText = (id, v) => { const el=document.getElementById(id); if (el) el.textContent=v; };
      const setHidden = (id, h) => { const el=document.getElementById(id); if (el) el.hidden=!!h; };
      function mapStatus(s){
        const t = String(s || "").toLowerCase();
        if (t === "in_stock")     return { text: "In Stock",     cls: "badge in_stock" };
        if (t === "backordered")  return { text: "Backordered",  cls: "badge backordered" };
        if (t === "out_of_stock") return { text: "Out of Stock", cls: "badge out_of_stock" };
        if (t === "discontinued") return { text: "Discontinued", cls: "badge discontinued" };
        return { text: s || "", cls: "badge" };
      }
      function formatUSD(n){
        const num = Number(String(n).replace(/[^0-9.]/g, ""));
        return Number.isFinite(num) ? "$" + num.toFixed(2) : "";
      }

      // cart
      function getCart(){ try { return JSON.parse(localStorage.getItem("cart") || "[]"); } catch(e){ return []; } }
      function setCart(cart){
        localStorage.setItem("cart", JSON.stringify(cart));
        const count = cart.reduce((s, it) => s + (Number(it.qty) || 0), 0);
        localStorage.setItem("cartCount", String(count));
        setText("cart-count", String(count));
      }
      function addOneToCart(id){
        const cart = getCart();
        const line = cart.find(x => x.id === id);
        if (line) line.qty = (Number(line.qty) || 0) + 1;
        else cart.push({ id, qty: 1 });
        setCart(cart);
      }

      /* ---------- CSV helpers (local to this page) ---------- */
      function stripBOM(text){ return text.replace(/^\uFEFF/, ""); }
      function parseCSV(text){
        text = stripBOM(text);
        const rows = [];
        let f = "", r = [], i = 0, q = false, c;
        while (i < text.length) {
          c = text[i];
          if (q) {
            if (c === '"') {
              if (text[i+1] === '"') { f += '"'; i += 2; continue; }
              q = false; i++; continue;
            }
            f += c; i++; continue;
          } else {
            if (c === '"') { q = true; i++; continue; }
            if (c === ",") { r.push(f); f=""; i++; continue; }
            if (c === "\n") { r.push(f); rows.push(r); r=[]; f=""; i++; continue; }
            if (c === "\r") { if (text[i+1] === "\n") i++; r.push(f); rows.push(r); r=[]; f=""; i++; continue; }
            f += c; i++; continue;
          }
        }
        r.push(f); rows.push(r);
        while (rows.length && rows[rows.length-1].every(v => v==="")) rows.pop();
        if (!rows.length) return [];
        const head = rows[0].map(h => h.toLowerCase().replace(/[\s_]+/g, ""));
        const out = [];
        for (let rr=1; rr<rows.length; rr++){
          const line = rows[rr], o = {};
          for (let cc=0; cc<head.length; cc++) o[head[cc]] = (line[cc] ?? "").trim();
          out.push(o);
        }
        return out;
      }
      async function getCSV(path){ const res = await fetch(path, { cache: "no-store" }); if(!res.ok) throw new Error(path+": "+res.status); return parseCSV(await res.text()); }

      function imagePathFrom(schematic){
        const stem = (schematic.image || schematic.id || "").trim();
        // explicit requirement: /schematics/<image>.webp
        return "/schematics/" + stem + ".webp";
      }

      /* ---------- Page loader ---------- */
      (async function loadSchematic(){
        const schemId = qp("id");
        const fail = (msg) => { setText("error", msg); setHidden("error", false); setHidden("loading", true); };

        try {
          if (!schemId) return fail("No schematic specified.");

          // get schematic record from DB (for name, modelId, image)
          const s = await DB.getSchematicById(schemId);
          if (!s) return fail("Schematic not found.");

          // Title
          const title = s.name ? "Schematic: " + s.name : "Schematic";
          const modelLabel = s.modelId ? " (Model " + s.modelId + ")" : "";
          setText("page-title", title + modelLabel);
          setText("schem-name", s.name || s.id);

          // Image on the left
          const img = document.getElementById("schem-img");
          img.src = imagePathFrom(s);
          img.alt = s.name ? ("Schematic – " + s.name) : "Schematic";

          // Load the two CSVs needed for the right table
          const [linksRows, partsRows] = await Promise.all([
            getCSV("schematic_parts.csv"),
            getCSV("parts.csv")
          ]);

          // Index parts by id for quick join; also let "number" work as fallback
          const partById = Object.create(null);
          const partByNum = Object.create(null);
          partsRows.forEach(p => {
            const id  = (p.id || "").trim();
            const num = (p.number || id).trim();
            if (id)  partById[id] = p;
            if (num) partByNum[num.toLowerCase()] = p;
          });

          // Filter link rows for this schematic; sort by Order (fallback to diagramNo)
          const links = linksRows
            .filter(l => (l.schematicid || "").trim() === schemId)
            .map(l => ({
              diagramNo: Number(l.diagramno || 0) || 0,
              order: Number(l.order || l.ord || 0) || 0,
              partId: (l.partid || "").trim()
            }))
            .sort((a,b) => (a.order - b.order) || (a.diagramNo - b.diagramNo));

          const tbody = document.getElementById("parts-body");
          tbody.innerHTML = "";

          if (!links.length) {
            const tr = document.createElement("tr");
            const td = document.createElement("td");
            td.colSpan = 6; td.textContent = "No parts for this schematic.";
            tr.appendChild(td); tbody.appendChild(tr);
          } else {
            links.forEach(link => {
              // join to part
              let part = partById[link.partId] || partByNum[link.partId.toLowerCase()] || null;

              const tr = document.createElement("tr");

              // Diagram Number
              const tdDiag = document.createElement("td");
              tdDiag.textContent = link.diagramNo ? String(link.diagramNo) : "";
              tr.appendChild(tdDiag);

              // Part Number (link to parts.html)
              const tdPN = document.createElement("td");
              const pnText = (part && part.number) ? part.number : link.partId;
              const a = document.createElement("a");
              a.href = "parts.html?id=" + encodeURIComponent(link.partId);
              a.textContent = pnText || link.partId || "";
              tdPN.appendChild(a);
              tr.appendChild(tdPN);

              // Name
              const tdName = document.createElement("td");
              tdName.textContent = part ? (part.name || part.description || "") : "";
              tr.appendChild(tdName);

              // Status (badge)
              const tdStatus = document.createElement("td");
              const badge = document.createElement("span");
              const st = mapStatus(part ? part.productstatus : "");
              badge.className = st.cls; badge.textContent = st.text;
              tdStatus.appendChild(badge);
              tr.appendChild(tdStatus);

              // Inventory
              const tdInv = document.createElement("td");
              const inv = part ? (Number(part.inventory || 0) || 0) : 0;
              tdInv.textContent = String(inv);
              tr.appendChild(tdInv);

              // Price (+ add to cart button in same cell to keep required headers)
              const tdPrice = document.createElement("td");
              tdPrice.style.whiteSpace = "nowrap";
              tdPrice.textContent = part && part.price ? formatUSD(part.price) + " " : "";

              const btn = document.createElement("button");
              btn.type = "button";
              btn.textContent = "Add to Cart";
              // enable only if in stock and inventory > 0
              const purchasable = part && String(part.productstatus || "").toLowerCase() === "in_stock" && inv > 0;
              btn.disabled = !purchasable;
              btn.addEventListener("click", function(){
                addOneToCart(link.partId);
                alert("Added to cart: " + (pnText || link.partId));
              });

              tdPrice.appendChild(btn);
              tr.appendChild(tdPrice);

              tbody.appendChild(tr);
            });
          }

          setHidden("loading", true);
          setHidden("schematic", false);
        } catch (e) {
          console.error(e);
          fail("Failed to load schematic data.");
        }
      })();
    </script>
  </body>
</html>
